# 자바와 비교해 보는 코틀린

- [기본 자료형](https://github.com/gihop/KotlinStudy/blob/master/자바와%20비교해%20보는%20코틀린.md#기본-자료형)

- [컬렉션](https://github.com/gihop/KotlinStudy/blob/master/자바와%20비교해%20보는%20코틀린.md#컬렉션)
- [클래스 및 인터페이스](https://github.com/gihop/KotlinStudy/blob/master/자바와%20비교해%20보는%20코틀린.md#클래스-및-인터페이스)
- [자료/자료형의 확인 및 변환](https://github.com/gihop/KotlinStudy/blob/master/자바와%20비교해%20보는%20코틀린.md#자료자료형의-확인-및-변환)
- [흐름 제어](https://github.com/gihop/KotlinStudy/blob/master/자바와%20비교해%20보는%20코틀린.md#흐름-제어)
- [제네릭](https://github.com/gihop/KotlinStudy/blob/master/자바와%20비교해%20보는%20코틀린.md#제네릭)
- [예외](https://github.com/gihop/KotlinStudy/blob/master/자바와%20비교해%20보는%20코틀린.md#예외)
- [널 안정성](https://github.com/gihop/KotlinStudy/blob/master/자바와%20비교해%20보는%20코틀린.md#널-안정성)

<br />

#기본 자료형

- 자바의 자료형은 값 자체를 직접 저장하는 원시타입(primitive type; int, double 등)과 객체의 참조 값을 저장하는 참조 타입(reference type; String 등)으로 나뉜다.
- 하지만 코틀린은 모든 타입을 객체로 표현하므로 원시 타입과 래퍼(wrapper; Integer, Double 등) 클래스를 구분하지 않는다.
- 코드를 작성하는 시점에서는 구분하지 않지만 컴파일 단계를 거치면서 가장 효율적인 타입으로 변환한다.
  - 값이나 변수의 타입으로 사용되는 경우: 원시타입으로 변환.
  - 컬렉션의 타입 인자로 사용되는 경우: 래퍼로 변환.

##숫자

- 숫자를 표현하는 모든 자료형(Byte, Double, Float, Int, Long, Short)은 Number 클래스를 상속한다.
- 자바의 Number 클래스 처럼 코틀린에서도 값을 다른 자료형으로 바꿔주는 함수를 제공한다.
  - 코틀린은 현재 숫자에 해당하는 문자를 반환하는 toChar() 함수를 추가로 제공한다.

| java.lang.Number     | kotlin.Number          |
| -------------------- | ---------------------- |
| byte byteValue()     | fun toByte(): Byte     |
| 없음                 | fun toChar(): Char     |
| double doubleValue() | fun toDouble(): Double |
| float floatValue()   | fun toFloat(): Float   |
| int intValue()       | fun toInt(): Int       |
| long longValue()     | fun toLong(): Long     |
| short shortValue()   | fun toShort(): Short   |

~~~kotlin
//10진수 표기
val decValue: Int = 100

//16진수 표기
val hexValue: Int = 0x100

//2진수 표기
val binaryValue: Int = 0b100

//Long에 한해 대문자만 사용한다.(대문자 I와 다른 문자와의 혼동 방지)
val longValue: Long = 100L

val doubleValue: Double = 100.1 //또는 1.00e2

val floatValue = 100.0f //또는 100f, 100.f는 안됨
~~~

- 사칙연산은(+,-,*,/) 자바와 동일하나 비트 연산자는 자바에 비해 좀 더 직관적이다.

| Java | Kotlin |
| ---- | ------ |
| &    | and    |
| \|   | or     |
| ^    | xor    |
| ~    | inv    |
| <<   | shl    |
| >>   | shr    |
| >>>  | ushr   |

### java

~~~java
int foo = (2 | 4) << 1;
~~~

###kotlin

~~~kotlin
val foo: Int = (2 or 4) shl 1
~~~



##문자

- 자바에서는 문자에 해당하는 아스키 코드를 문자 자료형에 숫자 형태로 대입할 수 있지만, 코틀린에서는 문자만 대입할 수 있으며 숫자를 대입할 경우 컴파일 에러가 발생한다.
  - 다른 자료형의 값을 문자 자료형에 대입하는 것이 불가피한 경우, toChar()를 사용하면 해결할 수 있다.

### java

~~~java
char c = 65; //문자 'A'의 아스키 코드 값
~~~

### kotlin

~~~kotlin
//컴파일 에러: Char 자료형 값에 Int 자료형인 65 대입 불가
val c : Char = 65

//성공
val c : Char = 'A'

//문자 'A'의 아스키 코드 값
val code : Int = 65

//code에 해당하는 문자를 할당
val ch : Char = code.toChar()
~~~

## 논리

~~~kotlin
val foo : Boolean = true
val bar : Boolean = false
~~~

| 연산자 | 의미 |
| ------ | ---- |
| \|\|   | OR   |
| &&     | AND  |
| !      | NOT  |

## 문자열

- 자바에서는 문자열 내 특정 위치의 문자에 접근하기 위해 charAt() 메서드를 사용하지만, 코틀린에서는 get() 혹은 대괄호와 인덱스를 사용한다.

~~~kotlin
val foo : String = "Lorem ipsum"

//ch1에 인덱스가 4인 문자 'm' 할당
val ch1 : Char = foo.get(4)

//ch2에 인덱스가 6인 문자 'i' 할당
val ch2 : Char = foo[6]
~~~

- 코틀린에서 제공하는 문자열 템플릿(string template) 기능을 사용하면 String.format() 함수와 달리 템플릿 문자열 내에 직접 인자를 대입한다.
- 템플릿 문자열에 포함한 인자는 앞에 달러 사인($)를 붙여 구분한다. 인자로 값이나 변수 대신 표현식을 넣고 싶다면 표현식 부분을 중괄호로 구분하면 된다.

~~~kotlin
var length : Int = 3000

//"Length: 3000 meters" 값 할당
val lengthText : String = "Length: $length meters"

val text : String = "Lorem ipsum"

//"TextLength: 4" 할당
val lengthText : String = "TextLength : ${text.length}"

//문자열 내에 달러 사인을 포함해야 하는 경우
val price : Int = 1000
val priceText : String = "Price : ${'$'}$price"
~~~

## 배열

- 배열 타입이 별도로 존재하는 자바와 달리, 코틀린에서의 배열은 타입 인자를 갖는 Array 클래스로 표현한다.
- arrayOf()는 코틀린 표준 라이브러리에 포함되어 있는 함수로, 입력받은 인자로 구성된 배열을 생성한다.

### java

~~~java
String[] words new String[] {"Lorem", "ipsum", "dolor", "sit"};
~~~

### kotlin

~~~kotlin
val words : Array<String> = arrayOf("Lorem", "ipsum", "dolor", "sit")
val intArr : Array<Int> = arrayOf(1, 2, 3, 4, 5)
~~~

<br />

#컬렉션

- 자바의 원시 타입 및 래퍼가 코틀린에서 사용되는 타입으로 처리되는 것과 달리, JVM을 기반으로 하는 코틀린에서 컬렉션(collection)은 자바에서 제공하는 클래스를 그대로 사용한다.
- 이때 타입 별칭(type alias)를 사용하여 컬렉션 내 다른 클래스와의 일관성을 유지한다.

| 원본 타입               | 타입 별칭                        |
| ----------------------- | -------------------------------- |
| java.util.ArrayList     | kotlin.collections.ArrayList     |
| java.util.HashMap       | kotlin.collections.HashMap       |
| java.util.HashSet       | kotlin.collections.HashSet       |
| java.util.LinkedHashMap | kotlin.collections.LinkedHashMap |
| java.util.LinkedHashSet | kotlin.collections.LinkedHashSet |
| java.util.RandomAccess  | kotlin.collections.RandomAccess  |
| java.util.SortedSet     | kotlin.collections.SortedSet     |
| java.util.TreeSet       | kotlin.collections.TreeSet       |

- 코틀린에서는 컬렉션 내 자료의 수정 가능 여부에 따라 컬렉션의 종류를 구분한다. 이는 새로운 타입을 선언하는 방시이 아닌, 인터페이스를 통해 사용 가능한 함수를 제한하는 방식으로 구현되어 있다.
  - 예로, 자바의 List 인터페이스는 Iterable, Collection 인터페이스를 상속하고 있으며, 이들 내에는 자료를 조회하고 수정하는 메서드가 모두 포함되어 있다.
  - 하지만 코틀린의 Collection, List 인터페이스에는 자료를 조회하는 함수만 포함되어 있으므로 자료가 한번 할당되면 수정이 불가하다. 그 대신, 각 인터페이스를 상속한 MutableCollection, MutableList 인터페이스에 자료를 수정하는 함수가 포함되어 있다.
    - Set, Map도 이와 동일한 규칙이 지정된다. 각각 두 종류의 인터페이스가 제공된다.

| 자료구조 | 자료 수정 불가          | 자료 수정 가능                 |
| -------- | ----------------------- | ------------------------------ |
| List     | kotlin.collections.List | kotlin.collections.MutableList |
| Map      | kotlin.collections.Map  | kotlin.collections.MutableMap  |
| Set      | kotlin.collections.Set  | kotlin.collections.MutableSet  |

- 배열과 마찬가지로, 코틀린 표준 라이브러리에서 컬렉션을 쉽게 생성하는 함수를 제공한다.

| 함수명        | 자료 수정가능 여부 | 반환 타입(실제 타입)             |
| ------------- | ------------------ | -------------------------------- |
| listOf()      | X                  | kotlin.collections.List          |
| arrayListOf() | O                  | kotlin.collections.ArrayList     |
| setOf()       | X                  | kotlin.collections.Set           |
| hashSetOf()   | O                  | kotlin.collections.HashSet       |
| linkedSetOf() | O                  | kotlin.collections.LinkedHashSet |
| sortedSetOf() | O                  | kotlin.collections.TreeSet       |
| mapOf()       | X                  | kotlin.collections.Map           |
| hashMapOf()   | O                  | kotlin.collections.HashMap       |
| linkedMapOf() | O                  | kotlin.collections.LinkedHashMap |
| sortedMapOf() | O                  | kotlin.collections.SortedMap     |

~~~kotlin
//자료를 수정할 수 없는 리스트 생성
var immutableList : List<String> = listOf("Lorem", "ipsum", "dolor", "sit")

//컴파일 에러: 자료 수정을 위한 함수를 지원하지 않음
immutableList.Add("amet")

//자료를 수정할 수 있는 리스트 생성
val mutableList : MutableList<String> = arrayListOf("Lorem", "ipsum", "dolor", "sit")

//자료 수정 가능
mutableList.add("amet")

//자료를 수정하지 않는 자료형으로 재할당
val immutableList2 : List<String> = mutableList

//컴파일 에러: 자료 수정을 위한 함수를 지원하지 않음
immutableList.add("amet")
~~~

- 자바의 컬렉션에서는 자료에 포함된 특정 항목에 접근할 때 get/set과 같은 메서드를 사용하지만 코틀린에서는 배열의 특정 원소에 접근하는 방법과 동일하게 컬렉션 내 항목에 접근할 수 있다.

~~~kotlin
val immutableList : List<String> = listOf("Lorem", "ipsum", "dolor", "sit")

//첫 번째 항목 읽기 - get(0)과 동일
val firstItem : String = immutableList[0]

//컴파일 에러: 값 설정 - set(0)과 동일
immutableList[0] = "Lollypop"

val mutalbleList : MutableList<String> = arrayListOf("Lorem", "ipsum", "dolor", "sit")

//자료 변경 가능
mutableList[0] = "Lollypop"
~~~

- 맵은 숫자 인덱스 대신 키 값을 넣어 항목에 접근할 수 있다.

~~~kotlin
val immutableMap : Map<String,Int> = mapOf(Pair("A", 65), Pair("B", 66))

//키 "A"에 해당하는 값 - get("A")와 동일
val code : Int = immutableMap["A"]

//컴파일 에러: 값 설정
immutableMap["C"] = 67

val mutableMap : HashMap<String, Int> = hashMapOf(Pair("A", 65), Pair("B", 66))

//자료 변경 가능 - put("C", 67)과 동일
mutableMap["C"] = 67
~~~

- 맵을 생성하는 함수들은 키와 값을 인자로 받기 위해 Pair 클래스를 사용하는데 코틀린 표준 라이브러리에서 제공하는 to 함수를 사용하면 Pair 형태의 값을 좀 더 편리하게 생성할 수 있다.

~~~kotlin
val map : Map<String, Int> = mapOf("A" to 65, "B" to 66)
~~~

<br />

## 클래스 및 인터페이스

<br />

## 자료/자료형의 확인 및 변환

<br />

## 흐름 제어

<br />

## 제네릭

<br />

## 예외

<br />

## 널 안정성

